面试题[07](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/)

很明显使用递归比较好，就是递归的参数传递比较麻烦

```
前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]
```

有些题解使用`preL,preR,inL,inR`四个变量来进行参数的传递，个人觉得比较麻烦和混乱，理不清，所以使用了三个变量，`p_start,i_start,length`三个变量表示,因为两个的长度一定是相同的。

* 通过查找根节点可以算出左子树的长度，记为`leftLength`,已经根节点在`inorder`中的下标 `privot`
* 左子树的`p_start,i_start,length`参数为`p_start+1,i_start,leftLength`
* 右子树的`p_start,i_start,length`参数为`p_start+lengthLeft+1,privot+1,length-1-lengthLeft`

总结：能使用较少的状态表示就用较少的状态表示，否则会引起混乱。

```java
class Solution {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
      return helper(preorder,0,inorder,0,preorder.length);
    }
    public TreeNode helper(int[] preorder,int p_start,int[] inorder,int i_start,int length){
        if(length<=0){
            return null;
        }else if(1 == length){
            return new TreeNode(preorder[p_start]);
        }
        TreeNode root = new TreeNode(preorder[p_start]);
        for(int i=i_start;i<i_start+length;i++){
            if(inorder[i] == preorder[p_start]){
                int lengthLeft=i-i_start;
               TreeNode left = helper(preorder,p_start+1,inorder,i_start,lengthLeft);
               TreeNode right = helper(preorder,p_start+lengthLeft+1,inorder,i+1,length-1-lengthLeft);
               root.left = left;
               root.right = right;
               return root;
            }
        }
        return null;
    }
}
```

看了大佬的空间换时间，优化一下。

```java
class Solution {
    Map<Integer,Integer> map;
    int[] preorder;
    public TreeNode buildTree(int[] preorder, int[] inorder) {

        int len = preorder.length;
        map = new HashMap<>(len);
        for(int i=0;i<len;i++){
            map.put(inorder[i],i);
        }
        this.preorder = preorder;
        return helper(0,0,len);
    }
    public TreeNode helper(int p_start,int i_start,int length){
        if(length<=0){
            return null;
        }else if(1 == length){
            return new TreeNode(preorder[p_start]);
        }
        TreeNode root = new TreeNode(preorder[p_start]);
        int privot = map.get(preorder[p_start]) ;
        int lengthLeft=privot-i_start;
        TreeNode left = helper(p_start+1,i_start,lengthLeft);
        TreeNode right = helper(p_start+lengthLeft+1,privot+1,length-1-lengthLeft);
        root.left = left;
        root.right = right;
        return root; 
    }
}
```





